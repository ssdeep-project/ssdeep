<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Fuzzy Hashing API: fuzzy.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fuzzy Hashing API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fuzzy.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>These functions allow a programmer to compute the fuzzy hashes (also called the context-triggered piecewise hashes) of <a class="el" href="fuzzy_8h.html#ae09a019e2b342abde2325e9a92b1d660">a buffer of text </a>, <a class="el" href="fuzzy_8h.html#a04749a87d07fc03d0d5eea1302c35585">the contents of a file on the disk </a>, and <a class="el" href="fuzzy_8h.html#a4d60c9cc7dda2e5dc6cf8219f71db71a">the contents of an open file handle </a> . There is also a function to <a class="el" href="fuzzy_8h.html#ab0b810944cf382d2de78e5dee8f2e436">compute the similarity between any two fuzzy signatures </a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div>
<p><a href="fuzzy_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8fb65abe5f9ce0175688fd85a8d481ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb65abe5f9ce0175688fd85a8d481ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a8fb65abe5f9ce0175688fd85a8d481ef">FUZZY_FLAG_ELIMSEQ</a>&#160;&#160;&#160;0x1u</td></tr>
<tr class="memdesc:a8fb65abe5f9ce0175688fd85a8d481ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuzzy_digest flag indicating to eliminate sequences of more than three identical characters <br /></td></tr>
<tr class="separator:a8fb65abe5f9ce0175688fd85a8d481ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97500b53eac624e53da89dea5165021d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97500b53eac624e53da89dea5165021d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a97500b53eac624e53da89dea5165021d">FUZZY_FLAG_NOTRUNC</a>&#160;&#160;&#160;0x2u</td></tr>
<tr class="memdesc:a97500b53eac624e53da89dea5165021d"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuzzy_digest flag indicating not to truncate the second part to SPAMSUM_LENGTH/2 characters. <br /></td></tr>
<tr class="separator:a97500b53eac624e53da89dea5165021d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a76507c72a195455009b62e28c671"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a137a76507c72a195455009b62e28c671">SPAMSUM_LENGTH</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a137a76507c72a195455009b62e28c671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2309f23e98c4c0370f32e3e3cb09afa5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a2309f23e98c4c0370f32e3e3cb09afa5">FUZZY_MAX_RESULT</a>&#160;&#160;&#160;(2 * <a class="el" href="fuzzy_8h.html#a137a76507c72a195455009b62e28c671">SPAMSUM_LENGTH</a> + 20)</td></tr>
<tr class="separator:a2309f23e98c4c0370f32e3e3cb09afa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20f6096457a2461764425a4801caf286"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a20f6096457a2461764425a4801caf286">fuzzy_new</a> (void)</td></tr>
<tr class="memdesc:a20f6096457a2461764425a4801caf286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="structfuzzy__state.html">fuzzy_state</a> object and return it.  <a href="#a20f6096457a2461764425a4801caf286">More...</a><br /></td></tr>
<tr class="separator:a20f6096457a2461764425a4801caf286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b3aa50a03a6bf7c5d2fca70760722b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a69b3aa50a03a6bf7c5d2fca70760722b">fuzzy_clone</a> (const struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *state)</td></tr>
<tr class="memdesc:a69b3aa50a03a6bf7c5d2fca70760722b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a <a class="el" href="structfuzzy__state.html">fuzzy_state</a> object and return it.  <a href="#a69b3aa50a03a6bf7c5d2fca70760722b">More...</a><br /></td></tr>
<tr class="separator:a69b3aa50a03a6bf7c5d2fca70760722b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27b47f8da90c33a7c8731aa4d031395"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#af27b47f8da90c33a7c8731aa4d031395">fuzzy_update</a> (struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *state, const unsigned char *buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:af27b47f8da90c33a7c8731aa4d031395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed the data contained in the given buffer to the state.  <a href="#af27b47f8da90c33a7c8731aa4d031395">More...</a><br /></td></tr>
<tr class="separator:af27b47f8da90c33a7c8731aa4d031395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0ca98cc46f085f7d3ef7a5b60e252"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a91d0ca98cc46f085f7d3ef7a5b60e252">fuzzy_digest</a> (const struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *state, char *result, unsigned int flags)</td></tr>
<tr class="memdesc:a91d0ca98cc46f085f7d3ef7a5b60e252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the fuzzy hash from the state.  <a href="#a91d0ca98cc46f085f7d3ef7a5b60e252">More...</a><br /></td></tr>
<tr class="separator:a91d0ca98cc46f085f7d3ef7a5b60e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0b1750ecb8b7d8e644f0ccec7bdf84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef0b1750ecb8b7d8e644f0ccec7bdf84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#aef0b1750ecb8b7d8e644f0ccec7bdf84">fuzzy_free</a> (struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *state)</td></tr>
<tr class="memdesc:aef0b1750ecb8b7d8e644f0ccec7bdf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose a fuzzy state. <br /></td></tr>
<tr class="separator:aef0b1750ecb8b7d8e644f0ccec7bdf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09a019e2b342abde2325e9a92b1d660"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#ae09a019e2b342abde2325e9a92b1d660">fuzzy_hash_buf</a> (const unsigned char *buf, uint32_t buf_len, char *result)</td></tr>
<tr class="memdesc:ae09a019e2b342abde2325e9a92b1d660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fuzzy hash of a buffer.  <a href="#ae09a019e2b342abde2325e9a92b1d660">More...</a><br /></td></tr>
<tr class="separator:ae09a019e2b342abde2325e9a92b1d660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d60c9cc7dda2e5dc6cf8219f71db71a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a4d60c9cc7dda2e5dc6cf8219f71db71a">fuzzy_hash_file</a> (FILE *handle, char *result)</td></tr>
<tr class="memdesc:a4d60c9cc7dda2e5dc6cf8219f71db71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fuzzy hash of a file using an open handle.  <a href="#a4d60c9cc7dda2e5dc6cf8219f71db71a">More...</a><br /></td></tr>
<tr class="separator:a4d60c9cc7dda2e5dc6cf8219f71db71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbcefe7aeba43ddabbcbe552ff44cee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a9cbcefe7aeba43ddabbcbe552ff44cee">fuzzy_hash_stream</a> (FILE *handle, char *result)</td></tr>
<tr class="memdesc:a9cbcefe7aeba43ddabbcbe552ff44cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fuzzy hash of a stream using an open handle.  <a href="#a9cbcefe7aeba43ddabbcbe552ff44cee">More...</a><br /></td></tr>
<tr class="separator:a9cbcefe7aeba43ddabbcbe552ff44cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04749a87d07fc03d0d5eea1302c35585"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#a04749a87d07fc03d0d5eea1302c35585">fuzzy_hash_filename</a> (const char *filename, char *result)</td></tr>
<tr class="memdesc:a04749a87d07fc03d0d5eea1302c35585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fuzzy hash of a file.  <a href="#a04749a87d07fc03d0d5eea1302c35585">More...</a><br /></td></tr>
<tr class="separator:a04749a87d07fc03d0d5eea1302c35585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b810944cf382d2de78e5dee8f2e436"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuzzy_8h.html#ab0b810944cf382d2de78e5dee8f2e436">fuzzy_compare</a> (const char *sig1, const char *sig2)</td></tr>
<tr class="separator:ab0b810944cf382d2de78e5dee8f2e436"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>These functions allow a programmer to compute the fuzzy hashes (also called the context-triggered piecewise hashes) of <a class="el" href="fuzzy_8h.html#ae09a019e2b342abde2325e9a92b1d660">a buffer of text </a>, <a class="el" href="fuzzy_8h.html#a04749a87d07fc03d0d5eea1302c35585">the contents of a file on the disk </a>, and <a class="el" href="fuzzy_8h.html#a4d60c9cc7dda2e5dc6cf8219f71db71a">the contents of an open file handle </a> . There is also a function to <a class="el" href="fuzzy_8h.html#ab0b810944cf382d2de78e5dee8f2e436">compute the similarity between any two fuzzy signatures </a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a2309f23e98c4c0370f32e3e3cb09afa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUZZY_MAX_RESULT&#160;&#160;&#160;(2 * <a class="el" href="fuzzy_8h.html#a137a76507c72a195455009b62e28c671">SPAMSUM_LENGTH</a> + 20)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The longest possible length for a fuzzy hash signature (without the filename) </p>

</div>
</div>
<a class="anchor" id="a137a76507c72a195455009b62e28c671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPAMSUM_LENGTH&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of an individual fuzzy hash signature component. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a69b3aa50a03a6bf7c5d2fca70760722b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a>* fuzzy_clone </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a <a class="el" href="structfuzzy__state.html">fuzzy_state</a> object and return it. </p>
<p>It can be used with fuzzy_update and fuzzy_digest independently of the original. It must be disposed with fuzzy_free like the original has to be cleared in this way. </p><dl class="section return"><dt>Returns</dt><dd>the cloned <a class="el" href="structfuzzy__state.html">fuzzy_state</a> or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab0b810944cf382d2de78e5dee8f2e436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuzzy_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sig1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sig2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the match score between two fuzzy hash signatures. </p><dl class="section return"><dt>Returns</dt><dd>Returns a value from zero to 100 indicating the match score of the two signatures. A match score of zero indicates the sigantures did not match. When an error occurs, such as if one of the inputs is NULL, returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a91d0ca98cc46f085f7d3ef7a5b60e252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuzzy_digest </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the fuzzy hash from the state. </p>
<p>This operation does not change the state at all. It reports the hash for the concatenation of the data previously fed using fuzzy_update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Where the fuzzy hash is stored. This variable must be allocated to hold at least FUZZY_MAX_RESULT bytes. </td></tr>
    <tr><td class="paramname">flags</td><td>is a bitwise or of FUZZY_FLAG_* macros. The absence of flags is represented by a zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success, non-zero on error </dd></dl>

</div>
</div>
<a class="anchor" id="ae09a019e2b342abde2325e9a92b1d660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuzzy_hash_buf </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the fuzzy hash of a buffer. </p>
<p>The computes the fuzzy hash of the first buf_len bytes of the buffer. It is the caller's responsibility to append the filename, if any, to result after computation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The data to be fuzzy hashed </td></tr>
    <tr><td class="paramname">buf_len</td><td>The length of the data being hashed </td></tr>
    <tr><td class="paramname">result</td><td>Where the fuzzy hash of buf is stored. This variable must be allocated to hold at least FUZZY_MAX_RESULT bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns zero on success, non-zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d60c9cc7dda2e5dc6cf8219f71db71a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuzzy_hash_file </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the fuzzy hash of a file using an open handle. </p>
<p>Computes the fuzzy hash of the contents of the open file, starting at the beginning of the file. When finished, the file pointer is returned to its original position. If an error occurs, the file pointer's value is undefined. It is the callers's responsibility to append the filename to the result after computation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Open handle to the file to be hashed </td></tr>
    <tr><td class="paramname">result</td><td>Where the fuzzy hash of the file is stored. This variable must be allocated to hold at least FUZZY_MAX_RESULT bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns zero on success, non-zero on error </dd></dl>

</div>
</div>
<a class="anchor" id="a04749a87d07fc03d0d5eea1302c35585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuzzy_hash_filename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the fuzzy hash of a file. </p>
<p>Opens, reads, and hashes the contents of the file 'filename' The result must be allocated to hold FUZZY_MAX_RESULT characters. It is the caller's responsibility to append the filename to the result after computation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to be hashed </td></tr>
    <tr><td class="paramname">result</td><td>Where the fuzzy hash of the file is stored. This variable must be allocated to hold at least FUZZY_MAX_RESULT bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns zero on success, non-zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cbcefe7aeba43ddabbcbe552ff44cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuzzy_hash_stream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the fuzzy hash of a stream using an open handle. </p>
<p>Computes the fuzzy hash of the contents of the open stream, starting at the current file position until reaching EOF. Unlike fuzzy_hash_file the stream is never seeked. If an error occurs, the result as well as the file position are undefined. It is the callers's responsibility to append the filename to the result after computation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Open handle to the stream to be hashed </td></tr>
    <tr><td class="paramname">result</td><td>Where the fuzzy hash of the file is stored. This variable must be allocated to hold at least FUZZY_MAX_RESULT bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns zero on success, non-zero on error </dd></dl>

</div>
</div>
<a class="anchor" id="a20f6096457a2461764425a4801caf286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a>* fuzzy_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="structfuzzy__state.html">fuzzy_state</a> object and return it. </p>
<p>To use it call fuzzy_update and fuzzy_digest on it. It must be disposed with fuzzy_free. </p><dl class="section return"><dt>Returns</dt><dd>the constructed <a class="el" href="structfuzzy__state.html">fuzzy_state</a> or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="af27b47f8da90c33a7c8731aa4d031395"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuzzy_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfuzzy__state.html">fuzzy_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feed the data contained in the given buffer to the state. </p>
<p>When an error occurs, the state is undefined. In that case it must not be passed to any function besides fuzzy_free. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data to be hashes </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The length of the given buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success, non-zero on error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 11 2014 15:58:55 for Fuzzy Hashing API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
